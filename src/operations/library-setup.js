// src/operations/library-setup.js

import { z } from 'zod';
import { resolveBlockSource, detectGitRemote, detectLocalBlocksDir } from '../common/block-utils.js';
import { daAdminRequest, formatURL, uploadHTML, uploadJSON } from '../common/utils.js';
import {
  buildLibraryPath,
  buildContentUrl,
  getDataSheet,
  getOptionsSheet,
  createLibraryJSON,
  addEntry
} from '../common/library-cfg-utils.js';
import { validateDADestination } from '../common/validation-utils.js';
import { generateBlockTemplate, extractBlockContent, analyzeBlock } from './blocks.js';
import { LIBRARY_TYPES, ADMIN_API_URL } from '../common/global.js';
import { registerLibraryType } from './config.js';

const AddBlockSchema = z.object({
  org: z.string().optional().describe('DA organization (destination for documentation). If not provided, will auto-detect from git origin'),
  repo: z.string().optional().describe('DA repository (destination for documentation). If not provided, will auto-detect from git origin'),
  blockName: z.string().describe('The block name to add'),
  baseFolder: z.string().optional().default('library').describe('Base folder for library (default: library)'),
  github: z.object({
    org: z.string(),
    repo: z.string(),
    branch: z.string().optional().default('main'),
    blocksPath: z.string().optional().default('blocks')
  }).optional().describe('ONLY provide if explicitly fetching from a different GitHub repo (repoless setup). Omit to auto-detect local blocks.'),
  useLocal: z.boolean().optional().describe('Explicitly use local file system. Omit to auto-detect.'),
  localBlocksPath: z.string().optional().describe('Custom path to local blocks directory. Omit to use ./blocks'),
  description: z.string().optional().describe('Optional description for Library Metadata'),
  sourceDocuments: z.array(z.string()).optional().describe('Optional array of source document paths to extract block examples from. Use "/" or "index" for homepage (searches in order). If not provided, documentation will be created without example content'),
  requestSamplePages: z.boolean().optional().default(false).describe('If true, returns suggestions for sample pages where blocks might be found, then exits (default: false)'),
  autoDetect: z.boolean().optional().default(true).describe('Auto-detect org/repo from current project if not provided (default: true)'),
  confirmDetection: z.boolean().optional().default(false).describe('If true and auto-detection is used, returns detection results for confirmation without executing (default: false)'),
  preview: z.boolean().optional().default(false).describe('Preview mode - show plan without executing (default: false)')
});

const SetupSchema = z.object({
  org: z.string().optional().describe('DA organization (destination for documentation). If not provided, will auto-detect from git origin'),
  repo: z.string().optional().describe('DA repository (destination for documentation). If not provided, will auto-detect from git origin'),
  baseFolder: z.string().optional().default('library').describe('Base folder for library (default: library)'),
  github: z.object({
    org: z.string(),
    repo: z.string(),
    branch: z.string().optional().default('main'),
    blocksPath: z.string().optional().default('blocks')
  }).optional().describe('ONLY provide if explicitly fetching from a different GitHub repo (repoless setup). Omit to auto-detect local blocks.'),
  useLocal: z.boolean().optional().describe('Explicitly use local file system. Omit to auto-detect.'),
  localBlocksPath: z.string().optional().describe('Custom path to local blocks directory. Omit to use ./blocks'),
  filter: z.string().optional().describe('Optional regex pattern to filter block names'),
  sourceDocuments: z.array(z.string()).optional().describe('Optional array of source document paths to extract block examples from. Use "/" or "index" for homepage (searches in order for each block). If not provided, documentation will be created without example content'),
  requestSamplePages: z.boolean().optional().default(false).describe('If true, returns suggestions for sample pages where blocks might be found, then exits (default: false)'),
  autoGenerateDocs: z.boolean().optional().default(true).describe('Automatically generate documentation for blocks (default: true)'),
  preserveExisting: z.boolean().optional().default(true).describe('Preserve existing documentation (default: true)'),
  autoDetect: z.boolean().optional().default(true).describe('Auto-detect org/repo from current project if not provided (default: true)'),
  confirmDetection: z.boolean().optional().default(false).describe('If true and auto-detection is used, returns detection results for confirmation without executing (default: false)'),
  preview: z.boolean().optional().default(false).describe('Preview mode - show plan without executing (default: false)')
});

function buildBlockFilePath(blockName, fileName) {
  return `${blockName}/${fileName}`;
}

async function resolveOrgRepo(args) {
  // If both org and repo are provided, use them directly
  if (args.org && args.repo) {
    return {
      org: args.org,
      repo: args.repo,
      autoDetected: false,
      source: 'explicit'
    };
  }

  // If auto-detection is disabled, require org and repo
  if (args.autoDetect === false) {
    throw new Error('org and repo are required when autoDetect is disabled');
  }

  // Auto-detect from git remote
  const gitInfo = await detectGitRemote();
  
  if (!gitInfo || !gitInfo.org || !gitInfo.repo) {
    throw new Error(
      'Could not auto-detect org/repo from git origin. Please provide org and repo explicitly.\n' +
      'Make sure you are in a git repository with a GitHub remote configured.'
    );
  }

  // Check if it's an EDS project
  const blocksDir = await detectLocalBlocksDir();
  const isEDS = !!blocksDir;

  return {
    org: gitInfo.org,
    repo: gitInfo.repo,
    autoDetected: true,
    source: isEDS ? 'git+eds' : 'git',
    gitRemote: gitInfo.remote,
    isEDS
  };
}

async function listAvailablePages(org, repo) {
  try {
    const url = `${ADMIN_API_URL}/list/${org}/${repo}/`;
    const response = await daAdminRequest(url);
    
    if (!response || !Array.isArray(response)) {
      return [];
    }
    
    // Filter for HTML pages only
    return response
      .filter(item => item.ext === 'html' || item.path.endsWith('.html'))
      .map(item => item.path)
      .filter(path => !path.includes('/drafts/') && !path.includes('/fragments/'))
      .sort();
  } catch {
    return [];
  }
}

function suggestSamplePages(pages, blockName = null) {
  const suggestions = {
    recommended: [],
    other: []
  };
  
  // Common pages that often have blocks
  const commonPages = ['/index', '/', '/home'];
  const demoPages = pages.filter(p => p.includes('demo') || p.includes('sample') || p.includes('example'));
  const rootPages = pages.filter(p => p.split('/').length <= 2);
  
  suggestions.recommended = [
    ...commonPages.filter(p => pages.includes(p)),
    ...demoPages.slice(0, 3),
    ...rootPages.slice(0, 5)
  ].filter((v, i, a) => a.indexOf(v) === i); // unique
  
  suggestions.other = pages
    .filter(p => !suggestions.recommended.includes(p))
    .slice(0, 10);
  
  return {
    message: blockName 
      ? `Looking for sample pages that might contain the '${blockName}' block.`
      : 'Looking for sample pages that might contain blocks.',
    totalPages: pages.length,
    recommended: suggestions.recommended,
    other: suggestions.other,
    usage: 'Call again with sourceDocuments parameter, e.g., sourceDocuments: ["/index", "/demo"]'
  };
}

function normalizeSourceDocuments(sourceDocuments) {
  if (!sourceDocuments || sourceDocuments.length === 0) {
    return null;
  }
  
  return sourceDocuments.map(path => {
    if (!path || path === '/' || path === '' || path === 'index' || path === 'home') {
      return '/index';
    }
    return path;
  });
}

function createBlockEntry(blockName, baseFolder, org, repo) {
  const displayName = blockName.charAt(0).toUpperCase() + blockName.slice(1);
  const blockPath = buildContentUrl(org, repo, `${baseFolder}/blocks/${blockName}`);
  return { name: displayName, path: blockPath };
}

async function uploadHTMLContent(org, repo, path, htmlContent) {
  const url = formatURL('source', org, repo, path, 'html');
  return uploadHTML(url, htmlContent);
}

async function uploadJSONContent(org, repo, path, jsonData) {
  const url = formatURL('source', org, repo, path, 'json');
  return uploadJSON(url, jsonData);
}


async function createBlockDoc(org, repo, docPath, blockName, variants, description, blockContent = null) {
  const template = generateBlockTemplate(blockName, description, variants, {}, blockContent);
  await uploadHTMLContent(org, repo, docPath, template);
  return buildContentUrl(org, repo, docPath);
}

async function checkBlockFiles(source, blockName) {
  const files = await source.listFiles(blockName);
  return files.filter(f => f.endsWith('.js') || f.endsWith('.css'));
}

async function checkDocExists(org, repo, docPath) {
  try {
    const url = formatURL('source', org, repo, docPath, 'html');
    await daAdminRequest(url);
    return true;
  } catch {
    return false;
  }
}

async function getExistingBlocksConfig(org, repo, baseFolder) {
  try {
    const configPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder);
    const url = formatURL('source', org, repo, configPath, 'json');
    return await daAdminRequest(url);
  } catch {
    return null;
  }
}

async function updateBlocksConfig(org, repo, baseFolder, entries) {
  const configPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder);
  const blocksJSON = await getExistingBlocksConfig(org, repo, baseFolder);

  let dataSheet = getDataSheet(blocksJSON);
  const optionsSheet = getOptionsSheet(blocksJSON);

  for (const entry of entries) {
    dataSheet = addEntry(dataSheet, entry);
  }

  const newBlocksJSON = createLibraryJSON(LIBRARY_TYPES.BLOCKS, dataSheet.data, optionsSheet);
  await uploadJSONContent(org, repo, configPath, newBlocksJSON);

  return {
    configPath,
    optionsPreserved: !!optionsSheet
  };
}

async function processBlockDocumentation(source, org, repo, blockName, baseFolder, description, sourceDocuments, docExists, preview) {
  if (docExists) {
    return {
      step: 4,
      action: 'Preserving existing documentation',
      status: 'completed',
      docPath: buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName),
      docUrl: buildContentUrl(org, repo, buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName)),
      created: false
    };
  }

  if (preview) {
    return {
      step: 4,
      action: 'Would create documentation',
      status: 'planned',
      docPath: buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName),
      docUrl: buildContentUrl(org, repo, buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName)),
      sourceDocuments: sourceDocuments || null
    };
  }

  const analysis = await analyzeBlock(source, blockName);
  const finalDescription = description || analysis.description;
  const { content: blockContent, sourceUsed } = await extractBlockContent(org, repo, sourceDocuments, blockName);
  const docPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName);
  const docUrl = await createBlockDoc(org, repo, docPath, blockName, analysis.variants, finalDescription, blockContent);

  const result = {
    step: 4,
    action: 'Creating block documentation',
    status: 'completed',
    created: true,
    docPath,
    docUrl,
    usedSourceContent: !!blockContent,
    sourceUsed: sourceUsed || null
  };
  
  // Provide helpful message if no source content was found
  if (!blockContent && !sourceDocuments) {
    result.note = 'Documentation created without example content. Set requestSamplePages=true to see available pages, or provide sourceDocuments for better documentation.';
  } else if (!blockContent && sourceDocuments) {
    result.note = `Block '${blockName}' not found in provided source pages. Try requestSamplePages=true to find pages that might contain this block.`;
  }
  
  return result;
}

async function addBlock(args) {
  const { blockName, baseFolder, description, sourceDocuments, preview, confirmDetection, requestSamplePages } = args;
  const sources = normalizeSourceDocuments(sourceDocuments);

  const result = {
    blockName,
    baseFolder,
    preview,
    steps: [],
    errors: []
  };

  try {
    // Resolve org/repo (auto-detect if not provided)
    result.steps.push({ step: 0, action: 'Resolving org/repo configuration', status: 'in_progress' });
    
    const orgRepoResolution = await resolveOrgRepo(args);
    const { org, repo } = orgRepoResolution;
    
    result.steps[0].status = 'completed';
    result.steps[0].org = org;
    result.steps[0].repo = repo;
    result.steps[0].autoDetected = orgRepoResolution.autoDetected;
    
    if (orgRepoResolution.autoDetected) {
      result.steps[0].source = orgRepoResolution.source;
      result.steps[0].gitRemote = orgRepoResolution.gitRemote;
      result.steps[0].isEDS = orgRepoResolution.isEDS;
      
      // If confirmation is requested, return early with detection results
      if (confirmDetection) {
        result.requiresConfirmation = true;
        result.message = `Auto-detected from git origin:\n  Org: ${org}\n  Repo: ${repo}\n  Remote: ${orgRepoResolution.gitRemote}\n  EDS Project: ${orgRepoResolution.isEDS ? 'Yes' : 'No'}\n\nTo proceed, call again with these values explicitly or set confirmDetection=false.`;
        return result;
      }
    }
    
    // If user requested sample pages, list them and return
    if (requestSamplePages) {
      result.steps.push({ step: 1, action: 'Listing available pages', status: 'in_progress' });
      
      const pages = await listAvailablePages(org, repo);
      const suggestions = suggestSamplePages(pages, blockName);
      
      result.steps[1].status = 'completed';
      result.steps[1].pagesFound = pages.length;
      result.samplePageSuggestions = suggestions;
      result.message = 'Sample page suggestions retrieved. Please provide sourceDocuments to proceed.';
      
      return result;
    }

    result.steps.push({ step: 1, action: 'Validating destination and resolving source', status: 'in_progress' });

    const validation = await validateDADestination(org, repo, baseFolder);
    if (!validation.valid) {
      result.errors.push(validation.error);
      result.steps[0].status = 'failed';
      result.steps[0].errors = [validation.error];
      return result;
    }

    const { source, metadata } = await resolveBlockSource(args);
    result.steps[0].status = 'completed';
    result.steps[0].source = metadata;

    result.steps.push({ step: 2, action: `Checking if block '${blockName}' exists in source`, status: 'in_progress' });

    const blockFiles = await checkBlockFiles(source, blockName);
    if (blockFiles.length === 0) {
      result.errors.push(`Block '${blockName}' not found or has no .js/.css files`);
      result.steps[1].status = 'failed';
      result.steps[1].error = 'Block not found';
      return result;
    }
    result.steps[1].status = 'completed';
    result.steps[1].exists = true;
    result.steps[1].files = blockFiles;

    const docPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName);
    const docUrl = buildContentUrl(org, repo, docPath);

    result.steps.push({ step: 3, action: 'Checking if block documentation exists', status: 'in_progress' });
    const docExists = await checkDocExists(org, repo, docPath);
    result.steps[2].status = 'completed';
    result.steps[2].exists = docExists;
    result.steps[2].path = docPath;
    result.steps[2].url = docUrl;

    if (preview) {
      result.steps.push({
        step: 4,
        action: docExists ? 'Would preserve existing documentation' : 'Would create documentation',
        status: 'planned',
        docPath,
        docUrl,
        sourceDocument: sourceDocument || null
      });

      result.steps.push({
        step: 5,
        action: 'Would add block to blocks.json',
        status: 'planned',
        configPath: buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder)
      });

      result.steps.push({
        step: 6,
        action: 'Would register in site config library sheet',
        status: 'planned',
        libraryType: 'Blocks'
      });

      return result;
    }

    const docStep = await processBlockDocumentation(
      source, org, repo, blockName, baseFolder, description, sources, docExists, preview
    );
    result.steps.push(docStep);

    result.steps.push({ step: 5, action: 'Adding block to blocks.json', status: 'in_progress' });

    const entry = createBlockEntry(blockName, baseFolder, org, repo);
    const configResult = await updateBlocksConfig(org, repo, baseFolder, [entry]);

    result.steps[4].status = 'completed';
    result.steps[4].configPath = configResult.configPath;
    result.steps[4].optionsPreserved = configResult.optionsPreserved;
    result.steps[4].entry = entry;

    result.steps.push({ step: 6, action: 'Registering in site config library sheet', status: 'in_progress' });

    const configPath = `${buildContentUrl(org, repo, buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder))}.json`;
    const regResult = await registerLibraryType(org, repo, 'Blocks', configPath);

    result.steps[5].status = 'completed';
    result.steps[5].registered = regResult.registered;
    result.steps[5].librarySheet = {
      existed: !regResult.createdSheet,
      entryCount: regResult.libraryEntryCount
    };

    result.success = true;
    return result;

  } catch (error) {
    result.errors.push(error.message);
    result.success = false;
    return result;
  }
}

async function processBlock(source, org, repo, blockName, baseFolder, sourceDocuments, autoGenerateDocs, preserveExisting, preview) {
  const blockResult = {
    name: blockName,
    action: 'unknown',
    docPath: null,
    docUrl: null,
    error: null
  };

  const blockFiles = await checkBlockFiles(source, blockName);

  if (blockFiles.length === 0) {
    blockResult.action = 'skipped';
    blockResult.error = 'No .js or .css files found';
    return blockResult;
  }

  const docPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName);
  const docUrl = buildContentUrl(org, repo, docPath);

  blockResult.docPath = docPath;
  blockResult.docUrl = docUrl;

  const docExists = await checkDocExists(org, repo, docPath);

  if (docExists && preserveExisting) {
    blockResult.action = 'preserved';
  } else if (autoGenerateDocs) {
    if (preview) {
      blockResult.action = docExists ? 'would_update' : 'would_create';
    } else {
      const analysis = await analyzeBlock(source, blockName);
      const { content: blockContent, sourceUsed } = await extractBlockContent(org, repo, sourceDocuments, blockName);
      await createBlockDoc(org, repo, docPath, blockName, analysis.variants, analysis.description, blockContent);
      blockResult.action = docExists ? 'updated' : 'created';
      blockResult.usedSourceContent = !!blockContent;
      blockResult.sourceUsed = sourceUsed || null;
    }
  } else {
    blockResult.action = 'skipped';
  }

  return blockResult;
}

async function setup(args) {
  const { baseFolder, filter, sourceDocuments, autoGenerateDocs, preserveExisting, preview, confirmDetection, requestSamplePages } = args;
  const sources = normalizeSourceDocuments(sourceDocuments);

  const result = {
    baseFolder,
    sourceDocuments: sources || null,
    preview,
    summary: {
      totalBlocks: 0,
      docsCreated: 0,
      docsUpdated: 0,
      docsPreserved: 0,
      docsSkipped: 0,
      configUpdated: false
    },
    blocks: [],
    errors: []
  };

  try {
    // Resolve org/repo (auto-detect if not provided)
    const orgRepoResolution = await resolveOrgRepo(args);
    const { org, repo } = orgRepoResolution;
    
    result.org = org;
    result.repo = repo;
    result.autoDetected = orgRepoResolution.autoDetected;
    
    if (orgRepoResolution.autoDetected) {
      result.detectionSource = orgRepoResolution.source;
      result.gitRemote = orgRepoResolution.gitRemote;
      result.isEDS = orgRepoResolution.isEDS;
      
      // If confirmation is requested, return early with detection results
      if (confirmDetection) {
        result.requiresConfirmation = true;
        result.message = `Auto-detected from git origin:\n  Org: ${org}\n  Repo: ${repo}\n  Remote: ${orgRepoResolution.gitRemote}\n  EDS Project: ${orgRepoResolution.isEDS ? 'Yes' : 'No'}\n\nTo proceed, call again with these values explicitly or set confirmDetection=false.`;
        return result;
      }
    }
    
    // If user requested sample pages, list them and return
    if (requestSamplePages) {
      const pages = await listAvailablePages(org, repo);
      const suggestions = suggestSamplePages(pages);
      
      result.samplePageSuggestions = suggestions;
      result.message = 'Sample page suggestions retrieved. Please provide sourceDocuments to proceed.';
      
      return result;
    }

    const validation = await validateDADestination(org, repo, baseFolder);
    if (!validation.valid) {
      result.errors.push(validation.error);
      return result;
    }

    const { source, metadata } = await resolveBlockSource(args);
    result.source = metadata;

    let directories = await source.listDirectories();

    if (filter) {
      const filterRegex = new RegExp(filter);
      directories = directories.filter(dir => filterRegex.test(dir.name));
    }

    result.summary.totalBlocks = directories.length;

    for (const dir of directories) {
      try {
        const blockResult = await processBlock(
          source, org, repo, dir.name, baseFolder, sources,
          autoGenerateDocs, preserveExisting, preview
        );

        if (blockResult.action === 'created') {
          result.summary.docsCreated++;
        } else if (blockResult.action === 'updated') {
          result.summary.docsUpdated++;
        } else if (blockResult.action === 'preserved') {
          result.summary.docsPreserved++;
        } else if (blockResult.action === 'skipped') {
          result.summary.docsSkipped++;
        }

        result.blocks.push(blockResult);

      } catch (error) {
        result.blocks.push({
          name: dir.name,
          action: 'error',
          docPath: null,
          docUrl: null,
          error: error.message
        });
        result.errors.push(`Block ${dir.name}: ${error.message}`);
      }
    }

    if (!preview) {
      const entries = result.blocks
        .filter(block => block.action === 'created' || block.action === 'updated' || block.action === 'preserved')
        .map(block => createBlockEntry(block.name, baseFolder, org, repo));

      if (entries.length > 0) {
        const configResult = await updateBlocksConfig(org, repo, baseFolder, entries);
        result.summary.configUpdated = true;
        result.configPath = configResult.configPath;

        const configPath = `${buildContentUrl(org, repo, buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder))}.json`;
        const regResult = await registerLibraryType(org, repo, 'Blocks', configPath);
        result.siteConfigRegistered = regResult.registered;
        result.librarySheet = {
          existed: !regResult.createdSheet,
          entryCount: regResult.libraryEntryCount
        };
      }
    }
    
    // Provide helpful note about sample pages if many blocks have no source content
    const blocksWithoutContent = result.blocks.filter(b => 
      (b.action === 'created' || b.action === 'updated') && !b.usedSourceContent
    ).length;
    
    if (blocksWithoutContent > 0 && !sourceDocuments) {
      result.note = `${blocksWithoutContent} block(s) created without example content. Consider using requestSamplePages=true to find pages with block examples, then call again with sourceDocuments for better documentation.`;
    } else if (blocksWithoutContent > 0 && sourceDocuments) {
      result.note = `${blocksWithoutContent} block(s) not found in provided source pages. Try requestSamplePages=true to discover other pages that might contain these blocks.`;
    }

    result.success = true;
    return result;

  } catch (error) {
    result.errors.push(error.message);
    result.success = false;
    return result;
  }
}

export const tools = [
  {
    name: 'da_library_add_block',
    description: 'Add a single block to the library. AUTO-DETECTS org/repo from git origin if not provided. AUTO-DETECTS local blocks if available. Set requestSamplePages=true to get suggestions for pages containing block examples. Provide sourceDocuments to extract real block content for better documentation. Set confirmDetection=true to review auto-detected config. Use preview=true to see what would be done.',
    schema: AddBlockSchema,
    handler: async (args) => addBlock(args)
  },
  {
    name: 'da_library_setup',
    description: 'Batch setup entire library. AUTO-DETECTS org/repo from git origin if not provided. AUTO-DETECTS and prefers LOCAL blocks from ./blocks folder. Set requestSamplePages=true to get suggestions for pages containing block examples. Provide sourceDocuments to extract real block content for all blocks. Set confirmDetection=true to review auto-detected config. Use preview=true to see what would be done.',
    schema: SetupSchema,
    handler: async (args) => setup(args)
  }
];
